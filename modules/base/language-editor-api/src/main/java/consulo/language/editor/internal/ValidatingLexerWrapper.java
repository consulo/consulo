// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package consulo.language.editor.internal;

import consulo.component.util.PluginExceptionUtil;
import consulo.language.ast.IElementType;
import consulo.language.lexer.FlexAdapter;
import consulo.language.lexer.Lexer;
import consulo.language.lexer.LexerPosition;
import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;

/**
 * This class verifies that delegate lexer generates a continuous sequence of tokens (without gaps), and that it
 * does not stall during iteration (generating empty tokens for the same offset continuously).
 */
public final class ValidatingLexerWrapper extends Lexer {
    private final Lexer myDelegate;
    private int myLastStartOffset;
    private int myLastEndOffset;
    private int myLastState;
    private IElementType myLastTokenType;
    private boolean myLastValuesActual;

    public ValidatingLexerWrapper(@Nonnull Lexer delegate) {
        myDelegate = delegate;
    }

    @Override
    @Nonnull
    public CharSequence getTokenSequence() {
        return myDelegate.getTokenSequence();
    }

    @Override
    @Nonnull
    public String getTokenText() {
        return myDelegate.getTokenText();
    }

    @Override
    public void start(@Nonnull CharSequence buffer, int startOffset, int endOffset, int initialState) {
        myDelegate.start(buffer, startOffset, endOffset, initialState);
        myLastValuesActual = false;
    }

    @Override
    public int getState() {
        return myLastValuesActual ? myLastState : myDelegate.getState();
    }

    @Override
    public @Nullable IElementType getTokenType() {
        if (!myLastValuesActual) {
            myLastTokenType = myDelegate.getTokenType();
            if (myLastTokenType != null) {
                myLastStartOffset = myDelegate.getTokenStart();
                myLastEndOffset = myDelegate.getTokenEnd();
                myLastState = myDelegate.getState();
            }
            myLastValuesActual = true;
        }
        return myLastTokenType;
    }

    @Override
    public int getTokenStart() {
        return myLastValuesActual ? myLastStartOffset : myDelegate.getTokenStart();
    }

    @Override
    public int getTokenEnd() {
        return myLastValuesActual ? myLastEndOffset : myDelegate.getTokenEnd();
    }

    @Override
    public void advance() {
        myDelegate.advance();

        int prevStart = 0;
        int prevEnd = 0;
        int prevState = 0;
        IElementType prevType = null;
        if (myLastValuesActual) {
            prevStart = myLastStartOffset;
            prevEnd = myLastEndOffset;
            prevState = myLastState;
            prevType = myLastTokenType;
        }

        myLastValuesActual = false;
        getTokenType(); // cache values

        if (prevType != null && myLastTokenType != null) {
            if (myLastStartOffset > myLastEndOffset) {
                throwException("Incorrect token offsets returned by lexer");
            }
            if (myLastStartOffset != prevEnd) {
                throwException("Discontinuous sequence of tokens is generated by lexer");
            }
            if (myLastEndOffset == myLastStartOffset && prevEnd == prevStart && myLastState == prevState && myLastTokenType == prevType) {
                throwException("Lexer is not progressing after calling advance()");
            }
        }
    }

    @Nonnull
    private String buildDiagnosticMessage(@Nonnull String message) {
        return message +
            "; delegateClass=" + myDelegate.getClass().getCanonicalName() +
            "; delegate=" + myDelegate +
            "; lastTokenType=" + myLastTokenType +
            "; lastStartOffset=" + myLastStartOffset +
            "; lastEndOffset=" + myLastEndOffset +
            "; lastState=" + myLastState;
    }

    @Override
    @Nonnull
    public LexerPosition getCurrentPosition() {
        return myDelegate.getCurrentPosition();
    }

    @Override
    public void restore(@Nonnull LexerPosition position) {
        myDelegate.restore(position);
        myLastValuesActual = false;
    }

    @Override
    @Nonnull
    public CharSequence getBufferSequence() {
        return myDelegate.getBufferSequence();
    }

    @Override
    public int getBufferEnd() {
        return myDelegate.getBufferEnd();
    }

    private void throwException(@Nonnull String message) {
        Class<? extends Lexer> lexerClass = myDelegate.getClass();
        boolean isFlexAdapter = lexerClass == FlexAdapter.class;
        throw PluginExceptionUtil.createByClass(
            buildDiagnosticMessage(message) + ": " + (isFlexAdapter ? myDelegate.toString() : lexerClass.getName()),
            null,
            isFlexAdapter ? ((FlexAdapter) myDelegate).getFlex().getClass() : lexerClass);
    }
}
