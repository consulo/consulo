/*
 * Copyright 2000-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package consulo.localHistory.impl.internal;

import consulo.disposer.Disposable;
import consulo.disposer.util.DisposableList;
import consulo.localHistory.LocalHistoryBundle;
import consulo.localHistory.impl.internal.tree.Entry;
import consulo.undoRedo.event.CommandEvent;
import consulo.undoRedo.event.CommandListener;
import consulo.util.dataholder.Key;
import consulo.util.lang.Pair;
import consulo.virtualFileSystem.VirtualFile;
import consulo.virtualFileSystem.event.*;
import consulo.virtualFileSystem.util.VirtualFileUtil;
import consulo.virtualFileSystem.util.VirtualFileVisitor;
import jakarta.annotation.Nonnull;

import java.util.List;
import java.util.Objects;

class LocalHistoryEventDispatcher implements VirtualFileManagerListener, CommandListener, BulkFileListener {
  private static final Key<Boolean> WAS_VERSIONED_KEY = Key.create(LocalHistoryEventDispatcher.class.getSimpleName() + ".WAS_VERSIONED_KEY");

  private final LocalHistoryFacade myVcs;
  private final IdeaGateway myGateway;
  private final DisposableList<BulkFileListener> myVfsEventListeners = DisposableList.create();

  LocalHistoryEventDispatcher(LocalHistoryFacade vcs, IdeaGateway gw) {
    myVcs = vcs;
    myGateway = gw;
  }

  @Override
  public void beforeRefreshStart(boolean asynchronous) {
    beginChangeSet();
  }

  @Override
  public void afterRefreshFinish(boolean asynchronous) {
    endChangeSet(LocalHistoryBundle.message("system.label.external.change"));
  }

  @Override
  public void commandStarted(@Nonnull CommandEvent e) {
    beginChangeSet();
  }

  @Override
  public void commandFinished(@Nonnull CommandEvent e) {
    endChangeSet(e.getCommandName());
  }

  void startAction() {
    myGateway.registerUnsavedDocuments(myVcs);
    myVcs.forceBeginChangeSet();
  }

  void finishAction(String name) {
    myGateway.registerUnsavedDocuments(myVcs);
    endChangeSet(name);
  }

  private void beginChangeSet() {
    myVcs.beginChangeSet();
  }

  private void endChangeSet(String name) {
    myVcs.endChangeSet(name);
  }

  private void fileCreated(@Nonnull VirtualFile file) {
    beginChangeSet();
    createRecursively(file);
    endChangeSet(null);
  }

  private void createRecursively(VirtualFile f) {
    VirtualFileUtil.visitChildrenRecursively(f, new VirtualFileVisitor<Void>() {
      @Override
      public boolean visitFile(@Nonnull VirtualFile f) {
        if (isVersioned(f)) {
          myVcs.created(f.getPath(), f.isDirectory());
        }
        return true;
      }

      @Override
      public Iterable<VirtualFile> getChildrenIterable(@Nonnull VirtualFile f) {
        // For unversioned files we try to get cached children in hope that they are already generated by content root manager:
        //  cached children may mean that there are versioned sub-folders or sub-files.
        return myGateway.isVersioned(f, true) ? IdeaGateway.loadAndIterateChildren(f) : IdeaGateway.iterateDBChildren(f);
      }
    });
  }

  private void beforeContentsChange(@Nonnull VFileContentChangeEvent e) {
    VirtualFile f = e.getFile();
    if (!myGateway.areContentChangesVersioned(f)) return;

    Pair<StoredContent, Long> content = myGateway.acquireAndUpdateActualContent(f, null);
    if (content != null) {
      myVcs.contentChanged(f.getPath(), content.first, content.second);
    }
  }

  private void handleBeforeEvent(VFileEvent event) {
    if (event instanceof VFileContentChangeEvent) {
      beforeContentsChange((VFileContentChangeEvent)event);
    }
    else if (event instanceof VFilePropertyChangeEvent && ((VFilePropertyChangeEvent)event).isRename() || event instanceof VFileMoveEvent) {
      VirtualFile f = Objects.requireNonNull(event.getFile());
      f.putUserData(WAS_VERSIONED_KEY, myGateway.isVersioned(f));
    }
    else if (event instanceof VFileDeleteEvent) {
      beforeFileDeletion((VFileDeleteEvent)event);
    }
  }

  private void propertyChanged(@Nonnull VFilePropertyChangeEvent e) {
    if (e.isRename()) {
      VirtualFile f = e.getFile();

      boolean isVersioned = myGateway.isVersioned(f);
      Boolean wasVersioned = f.getUserData(WAS_VERSIONED_KEY);
      if (wasVersioned == null) return;
      f.putUserData(WAS_VERSIONED_KEY, null);

      if (!wasVersioned && !isVersioned) return;

      String oldName = (String)e.getOldValue();
      myVcs.renamed(f.getPath(), oldName);
    }
    else if (VirtualFile.PROP_WRITABLE.equals(e.getPropertyName())) {
      if (!isVersioned(e.getFile())) return;
      VirtualFile f = e.getFile();
      if (!f.isDirectory()) {
        myVcs.readOnlyStatusChanged(f.getPath(), !(Boolean)e.getOldValue());
      }
    }
  }

  private void fileMoved(@Nonnull VFileMoveEvent e) {
    VirtualFile f = e.getFile();

    boolean isVersioned = myGateway.isVersioned(f);
    Boolean wasVersioned = f.getUserData(WAS_VERSIONED_KEY);
    if (wasVersioned == null) return;
    f.putUserData(WAS_VERSIONED_KEY, null);

    if (!wasVersioned && !isVersioned) return;

    myVcs.moved(f.getPath(), e.getOldParent().getPath());
  }

  private void beforeFileDeletion(@Nonnull VFileDeleteEvent e) {
    VirtualFile f = e.getFile();
    Entry entry = myGateway.createEntryForDeletion(f);
    if (entry != null) {
      myVcs.deleted(f.getPath(), entry);
    }
  }

  private boolean isVersioned(VirtualFile f) {
    return myGateway.isVersioned(f);
  }

  @Override
  public void before(@Nonnull List<? extends VFileEvent> events) {
    myGateway.runWithVfsEventsDispatchContext(events, true, () -> {
      for (VFileEvent event : events) {
        handleBeforeEvent(event);
      }

      for (BulkFileListener listener : myVfsEventListeners) {
        listener.before(events);
      }
    });
  }

  @Override
  public void after(@Nonnull List<? extends VFileEvent> events) {
    myGateway.runWithVfsEventsDispatchContext(events, false, () -> {
      for (VFileEvent event : events) {
        handleAfterEvent(event);
      }
      for (BulkFileListener listener : myVfsEventListeners) {
        listener.after(events);
      }
    });
  }

  private void handleAfterEvent(VFileEvent event) {
    if (event instanceof VFileCreateEvent) {
      VirtualFile file = event.getFile();
      if (file != null) {
        fileCreated(file);
      }
    }
    else if (event instanceof VFilePropertyChangeEvent) {
      propertyChanged((VFilePropertyChangeEvent)event);
    }
    else if (event instanceof VFileMoveEvent) {
      fileMoved((VFileMoveEvent)event);
    }
  }

  void addVirtualFileListener(BulkFileListener virtualFileListener, Disposable disposable) {
    myVfsEventListeners.add(virtualFileListener, disposable);
  }
}